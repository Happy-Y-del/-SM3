#include "sm3.h"
#include <stdlib.h>
#include <string.h>

// 初始链接变量IV（GM/T 0004-2012标准定义）
const uint32_t SM3_IV[SM3_IV_SIZE] = {
    0x7380166f, 0x4914b2b9, 0x172442d7, 0xda8a0600,
    0xa96f30bc, 0x163138aa, 0xe38dee4d, 0xb0fb0e4e
};

// 循环左移（32位字）：n∈[1,31]
uint32_t sm3_rotl(uint32_t x, int n) {
    return (x << n) | (x >> (32 - n));
}

// 置换函数P0
uint32_t sm3_P0(uint32_t x) {
    return x ^ sm3_rotl(x, 9) ^ sm3_rotl(x, 17);
}

// 置换函数P1
uint32_t sm3_P1(uint32_t x) {
    return x ^ sm3_rotl(x, 15) ^ sm3_rotl(x, 23);
}

// 布尔函数FF：j=0-15→X^Y^Z；j=16-63→(X&Y)|(X&Z)|(Y&Z)
uint32_t sm3_FF(uint32_t X, uint32_t Y, uint32_t Z, int j) {
    return (j <= 15) ? (X ^ Y ^ Z) : ((X & Y) | (X & Z) | (Y & Z));
}

// 布尔函数GG：j=0-15→X^Y^Z；j=16-63→(X&Y)|((~X)&Z)
uint32_t sm3_GG(uint32_t X, uint32_t Y, uint32_t Z, int j) {
    return (j <= 15) ? (X ^ Y ^ Z) : ((X & Y) | ((~X) & Z));
}

// 消息填充模块：严格遵循GM/T 0004-2012填充规则
void sm3_pad(const uint8_t* input, size_t input_len, uint8_t** output, size_t* output_len) {
    size_t l_bit = input_len * 8;  // 原始消息长度（bit）
    size_t pad_total_bit;          // 填充后总长度（bit，必须是512的整数倍）

    // 计算填充后总长度：满足 (l+1+k) ≡ 448 mod 512，最终总长度 = l+1+k+64
    if ((l_bit + 1) % 512 <= 448) {
        pad_total_bit = l_bit + 1 + (448 - (l_bit + 1) % 512) + 64;
    }
    else {
        pad_total_bit = l_bit + 1 + (512 + 448 - (l_bit + 1) % 512) + 64;
    }
    *output_len = pad_total_bit / 8;  // 转换为字节数

    // 分配填充后内存并初始化0
    *output = (uint8_t*)malloc(*output_len);
    if (*output == NULL) {
        *output_len = 0;
        return;
    }
    memset(*output, 0, *output_len);

    // 复制原始消息
    if (input_len > 0) {
        memcpy(*output, input, input_len);
    }

    // 补1个"1"bit（对应字节0x80，即10000000）
    (*output)[input_len] = 0x80;

    // 补64bit原始长度（大端序存储）
    uint64_t l_bit64 = (uint64_t)l_bit;
    for (int i = 0; i < 8; i++) {
        (*output)[*output_len - 8 + i] = (l_bit64 >> (56 - i * 8)) & 0xFF;
    }
}
